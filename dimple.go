// Package dimple provides a simple dependency injection container for Go.
// Dimple is licensed under the MIT.
//
// A simple example:
//
//     d := NewDimple()
//     kirk := NewKirk()
//     d.SetValue("kirk", kirk)
//     k := d.Get("kirk").(Kirk)
//
// In this simple example Kirk is attached to the container. Every time Get is
// called the same Kirk item is retrieved.
//
// A generator example. Sometimes you need to generate a new item each time.
//
//     d := NewDimple()
//     d.SetGenerator("tribble", func(d *dimple.Dimple) interface{} {
//         return NewTribbles()
//     })
//     a := d.Get("tribble")
//     b := d.Get("tribble")
//
// In the case of generators, a new item is returned each time.
//
// Generator items in the container have access to the other items in the
// container. For example,
//
//     d := NewDimple()
//     kirk := NewKirk()
//     d.SetValue("kirk", kirk)
//     d.SetGenerator("tribble", func(d *dimple.Dimple) interface{} {
//         return NewTribbles(d.Get("kirk").(Kirk))
//     })
//
// This is useful for many cases. For example, the configuration for a mail
// system could be placed on the container along with the mail system itself.
// The mail system could be returned via a generator that retrieves the
// configuration from the container.
//
// Items in the container can be extended. For example,
//
//     d := NewDimple()
//     d.SetGenerator("tribble", func(d *dimple.Dimple) interface{} {
//         return NewTribbles(d.Get("kirk").(Kirk))
//     })
//     d.Extend("tribble", func(o interface{}, d *dimple.Dimple) interface{}) {
//       o.ExtraFuzzy()
//       return o
//     })
//     t := d.Get("tribble")
//
// In this case the item returned was generated by the original generator, that
// items was passed into the extended item, and the response from that was
// returned via Get.
//
// The overall goal of dimple is to provide a simple mechanism to retrieve items
// from the container while providing flexibility in where those items come from.
package dimple

// Dimple is a dependency injection container.
type Dimple struct {
	// The raw value or generator for the container.
	Raw map[string]interface{}

	// If a value is being created by a generator or not.
	generator map[string]bool
}

// NewDimple creates a new Dimple dependency injection container.
func NewDimple() Dimple {
	d := Dimple{}
	d.Raw = make(map[string]interface{})
	d.generator = make(map[string]bool)

	return d
}

// Get retrieves an item from the container.
func (d *Dimple) Get(name string) interface{} {
	gen, exists := d.generator[name]
	if exists == true && gen == true {
		val := d.Raw[name].(func(d *Dimple) interface{})
		r := val(d)
		return r
	}

	return d.Raw[name]
}

// SetValue sets a value on the container, keyed by a string name, to be reused.
func (d *Dimple) SetValue(name string, value interface{}) {
	d.Raw[name] = value
}

// SetGenerator sets a generator on the container. The value returned from the
// generator is seen in the same manner as a normal value. On the receiving end,
// via Get(), you cannot tell if it came from a value or generator.
func (d *Dimple) SetGenerator(name string, generator func(d *Dimple) interface{}) {
	d.Raw[name] = generator
	d.generator[name] = true
}

// Extend wraps an existing item in the container with the function passed in.
// The existing raw item is passed in along with the container.
func (d *Dimple) Extend(name string, extension func(o interface{}, d *Dimple) interface{}) {
	defer func() { d.generator[name] = true }()
	ov := d.Raw[name]
	var old interface{}
	gen, exists := d.generator[name]
	d.Raw[name] = func(d *Dimple) interface{} {
		if exists == true && gen == true {
			val := ov.(func(d *Dimple) interface{})
			old = val(d)
		} else {
			old = ov
		}

		return extension(old, d)
	}
}
